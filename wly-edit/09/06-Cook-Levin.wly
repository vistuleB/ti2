|> Sub
    title=Ganz NP reduziert auf SAT: das Cook-Levin-Theorem
    Hier eine kurze Übersicht über die Reduktionen, die Sie im vorherigen
    Kapitel kennengelernt haben.

    |> ol
        |> li
            `3-Colorability $\leq_p$ CNF-Satisfiability`{sc}
        |> li
            `CNF-Satisfiability $\leq_p$ 3-SAT`{sc}
        |> li
            `3-SAT $\leq_p$ 3-Colorability`{sc}
        |> li
            `3-SAT $\leq_p$ Independent Set`{sc}
        |> li
            `Hamilton Path $\leq_p$ Hamilton Cycle`{sc}
        |> li
            `Hamilton Cycle $\leq_p$ Hamilton Path`{sc}

    Mit etwas Anstrengung würden wir auch`Hamilton Path $\leq_p$ CNF-Satisfiability`{sc}hinkriegen.
    Alle erwähnten Probleme Mitglieder von NP: wir können Ja-Instanzen effizient
    verifizieren. Gibt es in NP "Allzweckwaffen", also Probleme, mit deren
    Hilfe wir _alle anderen_ NP-Probleme lösen könnten?

    |> Statement
        title=*Definition*
        Ein Entscheidungsproblem $L \subseteq \Sigma^*$ heißt _NP-schwer_, wenn
        für jedes Problem $K \in {\rm NP}$ gilt: $K \leq_p L$. Wenn sich also
        jedes NP-Problem auf $K$ in polynomieller Zeit reduzieren lässt. $L$ ist
        NP-_vollständig_, wenn zusätzlich $L$ selbst in NP ist.

    |> Statement
        title=*Theorem*
        *(Cook-Levin-Theorem).* 3-SAT ist NP-vollständig. In anderen Worten: Sei
        $L$ ein beliebiges Entscheidgungsproblem aus NP. Dann gilt `$L \leq_p$
        3-SAT`{sc}.

    Wir führen das Zwischenproblem `Circuit-SAT`{sc} ein und zeigen (1) dass
    $L \leq_p$ `Circuit-SAT`{sc} und (2) `Circuit-SAT $\leq_p$ 3-SAT`{sc}
    gilt.

    |> Statement
        title=*Problem*
        (`Circuit-SAT`{sc}). Gegeben ein Boolescher Schaltkreis $C$ mit $n$ Eingabevariablen.
        Gibt es ein $x \in \{0,1\}^n$ mit $C(x) = 1$?

    Offensichtlich gilt `CNF-Satisfiability $\leq_p$ Circuit-SAT`{sc} und
    `3-SAT $\leq_p$ Circuit-SAT`{sc}, da CNF-Formeln (und somit auch $3$-CNF-Formeln)
    Spezialfälle Boolescher Schaltkreise sind.

    |> Statement
        title=*Lemma*
        Sei $L \in {\rm NP}$. Dann gilt `$L \leq_p$ Circuit-SAT`{sc}.

    |> Highlight
        *Beweis.* Wir können annehmen, dass $L \subset \{0,1\}^*$, da wir andernfalls
        eine geeignete Codierung $\Sigma \rightarrow \{0,1\}^*$ wählen können.
        Da $L \in {\rm NP}$ ist, gibt es ein $k \in \N$ und eine Zertifikatmaschine
        $M$ mit Laufzeit $t(n) = n^k$, so dass

        \begin{align*}
        x \in L \Longleftrightarrow \exists z \in \{0,1\}^{t(|x|)}: M(x,z) = \texttt{accept}
        \end{align*}

        |> span
            handle=theorem-tms-to-circuits
        besagt, dass wir eine Turingmaschine von Laufzeit $t(n)$ in einen Schaltkreis
        $C$ der Größe $O(t(n)^2)$ umformen können, so dass

        \begin{align*}
        \forall x \in \{0,1\}^n: \quad x \in L \Longleftrightarrow C(x) = 1 \ .
        \end{align*}

        Diese Konstruktion funktioniert für jede Inputgröße $n$, aber wir müssen
        $n$ natürlich zum Zeitpunkt der Umformung kennen. Der gleiche Beweis lässt
        uns die Zertifikatmaschine $M$, die zwei Inputs $x$ und $z$ nimmt, in
        einen Schaltkreis $C$ von Größe $O(t(n)^2)$ mit $n + t(n)$ Eingabevariablen
        umformen, so dass

        \begin{align*}
        \forall x \in \{0,1\}^n, z \in \{0,1\}^{t(n)}: \quad
        M(x,z) = \texttt{accept} \Longleftrightarrow C(x,z) = 1
        \end{align*}

        Somit gilt für jedes $x \in \{0,1\}^n$ mit $t := t(n)$:

        \begin{align*}
        x \in L \quad&\Longleftrightarrow \exists z \in \{0,1\}^t: M(x,z) = \texttt{accept} \\
        &
        \Longleftrightarrow \exists z \in \{0,1\}^t: C(x,z) = 1 \ . \\
        \end{align*}

        Unsere Reduktion von $L$ auf `Ciruit-SAT`{sc} geht nun wie folgt: Bei
        Eingabewort $x \in \{0,1\}^*$ setzen wir $n := |x|$ und $t := t(n)$. Wir
        führen die Umformung von $M$ in einen Schaltkreis $C$ durch. Dieser
        $C$ hat $n + t$ Eingabevariablen, $n$ viele für das Eingabeband von
        $M$ und $t$ viele für das Zertifikatband. Da wir $x$ bereits kennen, verkabeln
        wir es fest in $C$, d.h. wir ersetzen die $i$-te Eingabevariable von
        $C$ durch den Booleschen Wert $x_i$ (dies ist eine Konstante, keine Variable,
        da wir ein konkretes Eingabewort $x \in \{0,1\}^n$ gegebenen haben) und
        erhalten einen Schaltkreis

        \begin{align*}
        D := C(x, \cdot)
        \end{align*}

        mit $t$ Eingabe-Gates. Nach Konstruktion gilt

        \begin{align*}
        x \in L&\Longleftrightarrow \exists z \in \{0,1\}^t : D(z) = 1
        \end{align*}

        also genau dann, wenn `$D \in$ Circuit-SAT`{sc}.
        |> QED

    |> Statement
        title=*Lemma*
        `Circuit-SAT`{sc} $\leq_p$ `3-SAT`{sc}.

    |> Highlight
        *Beweis.* Wir haben also einen Schaltkreis $C$ mit $n$ Eingabe-Variablen
        und $m$ Gates gegeben. Unsere Aufgabe ist es, eine $3$-CNF-Formel $F$
        zu bauen, so dass $F$ genau dann erfüllbar ist, wenn $C$ erfüllbar ist.
        Wir demonstrieren die Umformung an einem Beispiel:

        |> figure
            |> img
                style=height:16em
                src=img/09-complexity-theory/circuit-to-3-cnf/circuit-to-3-cnf-01-01.svg

        Ich will zuerst diskutieren, was _nicht_ geht. Der obige Schaltkreis (so
        wie jeder) berechnet eine Funktion
        $f_C: \{0,1\}^n \rightarrow \{0,1\}$. Das Problem `Circuit-SAT`{sc} fragt
        nun, ob $f_C$ nicht die konstante Nullfunktion ist. Wir können im Allgemeinen
        $f_C$ _nicht_ als $3$-CNF-Formel schreiben. Obigen Schaltkreis zum Beispiel
        nicht. Wir können $f_C$ allgemein als CNF-Formel schreiben mit der Wahrheitstabellenmethode.
        Hierfür brauchen wir aber $2^n$ Schritte, und unsere Reduktion wäre nicht
        mehr polynomiell. Allerdings muss die $3$-CNF-Formel $F$, also das Ergebnis
        der Reduktion, auch nicht äquivalent zu $C$ sein, sondern nur _SAT-äquivalent_:
        $F$ muss genau dann erfüllbar sein, wenn $C$ erfüllbar ist. Wenden wir
        uns obigem Schaltkreis zu. Wir führen für jedes Gate eine Variable ein,
        die seinen Output darstellen soll. Hier sind das
        $g_1, g_2, \dots, g_{11}$:

        |> figure
            |> img
                style=height:16em
                src=img/09-complexity-theory/circuit-to-3-cnf/circuit-to-3-cnf-01-02.svg

        Die Aussage _$g_4$ ist der Output des zweiten OR-Gates von links_ können
        wir nun schreiben als $g_4 \leftrightarrow (x \vee y)$. Das
        $\leftrightarrow$ ist hierbei der Boolesche Operator, der Gleichheit testet.
        Wir tun dies für jedes Gate und erhalten folgende Formel:

        \begin{align*}
        &(g_1 \leftrightarrow (\neg x)) \quad \wedge \\
        &(g_2 \leftrightarrow (\neg y)) \quad \wedge \\
        &(g_3 \leftrightarrow (g_1 \vee g_2)) \quad \wedge \\
        &(g_4 \leftrightarrow (x \vee y)) \quad \wedge \\
        &(g_5 \leftrightarrow (g_3 \wedge g_4)) \quad \wedge \\
        &(g_6 \leftrightarrow (\neg z)) \quad \wedge \\
        &(g_7 \leftrightarrow (\neg w)) \quad \wedge \\
        &(g_8 \leftrightarrow (g_6 \vee g_7)) \quad \wedge \\
        &(g_9 \leftrightarrow (z \vee w)) \quad \wedge \\
        &(g_{10} \leftrightarrow (g_8 \wedge g_9)) \quad \wedge \\
        &(g_{11} \leftrightarrow (g_{5} \vee g_{10}))\\
        &(g_{11})
        \end{align*}

        Die ersten 11 Teilausdrücke stellen sicher, dass jedes $g_i$ den "richtigen"
        Wert annimmt. Mit dem letzten Teilausdruck $(g_{11})$ drücken wir aus,
        dass wir wollen, dass der Schaltkreis $1$ ausgibt. Es gilt nun:

        |> ol
            |> li
                Wenn eine Belegung der Variablen $(x, y, z, w, g_1, \dots, g_{11})$ die
                Formel $F$ erfüllt, dann haben alle Variablen $g_i$ den Wert, den das
                entsprechende Gate ausgibt, und somit gilt $C(x,y,z,w) = 1$.
            |> li
                Falls $C(x,y,z,w) = 1$ gilt, dann können wir $g_i$ auf den Output-Wert
                des $i$-ten Gates setzen und erhalten eine Belegung der Variablen
                $(x, y, z, w, g_1, \dots, g_{11})$, die $F$ erfüllt.

        Im allgemeinen gilt also für jedes $x \in \{0,1\}^n$:

        \begin{align*}
        C(x) = 1 \Longleftrightarrow \exists g \in \{0,1\}^m: F(x,g) = 1 .
        \end{align*}

        Die obige Formel ist nicht in konjunktiver Normalform, da jeder Teilausdruck
        Operatoren wie $\leftrightarrow$ etc. enthält. Jeder Teilausdruck ist
        aber in sich eine Formel mit drei Variablen; somit können wir eine Wahrheitstabelle
        mit $8$ Zeilen anlegen und ihn in eine äquivalente 3-CNF-Formel mit maximal
        $8$ Klauseln umformen. Die schlussendliche $3$-CNF-Formel hat somit
        $n + m$ Variable (die Eingabevariablen von $C$ plus eine für jedes Gate)
        und maximal $8m + 1$ Klauseln, von denen jede höchstens drei Variable
        enthält.
        |> QED