|> Sub
    title=Einen Parser in Java implementieren
    
    |> div
        class=well alert-info
        Den vollständigen Quelltext, den wir in der Vorlesung geschrieben haben,
        finden Sie in der Datei 
        |> a
            href=https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/code/parsing/arithmetic-in-class/ArithmeticGrammar.java
            ArithmeticGrammar.java
        .
        
    Ich möchte nun eine kontextfreie Grammatik für arithmetische Ausdrücke der
    Form 
    |> tt
        ((31+402)*83)
    \ entwerfen. Der Einfachheit halber bestehe ich
    auf strenger Klammerung, so wäre 
    |> tt
        (2*(1+2+3))
    \ zum Beispiel nicht erlaubt.
    Unsere Grammatik soll allgemeine Dezimalzahlen darstellen können.
    Das Alphabet ist somit
    $\Sigma = \{\texttt{0},\texttt{1},\texttt{2},\texttt{3},\texttt{4},
    \texttt{5},\texttt{6},\texttt{7},\texttt{8},\texttt{9},
    \texttt{+},\texttt{*},\texttt{(},\texttt{)}\}$.
    Die Produktionsregeln sind:
    \begin{align*}
    E&amp;\rightarrow N \tag{JustNumber} \\
    E&amp;\rightarrow \texttt{(}E \texttt{+} E\texttt{)} \tag{Sum} \\
    E&amp;\rightarrow \texttt{(}E \texttt{*} E\texttt{)} \tag{Product}\\
    N&amp;\rightarrow D \tag{SingleDigit} \\
    N&amp;\rightarrow ND \tag{NumberDigit} \\
    D&amp;\rightarrow \texttt{0}\ | \ \texttt{1}\ | \ \texttt{2}\ | \ \texttt{3}\ | \ \texttt{4}\ | \
    \texttt{5}\ | \ \texttt{6}\ | \ \texttt{7}\ | \ \texttt{8}\ | \ \texttt{9}
    \end{align*}
    
    Die Nichtterminale sind also $E$ (Expression), $N$ (Number) und $D$ (Digit). Wir haben auch
    den einzelnen Produktionen Namen gegeben, bis auf die der Form $D \rightarrow i$.
    Was soll nun unser Parser tun? Er soll, gegeben ein Eingabewort $w \in L$, den
    _Ableitungsbaum_ konstruieren, für 
    |> tt
        ((31+402)*83)
    \ also
    |> figure
        |> img
            style=height:20em
            src=./img/context-free/arithmetic-syntax-tree.svg
            
    Wie wir diesen Baum in Java repräsentieren, darüber sprechen wir in einer Minute.
    Zuerst aber: wir wollen mit diesem Baum etwas Sinnvolles tun. Zum Beispiel
    _auswerten_, so dass am Ende eine Zahl rauskommt, im obigen Beispiel
    also $(31 + 402) \cdot 83 = 35939$. Oder den Ausdruck umformen von
    Infix-Notation zu Präfixnotation, also
    |> tt
        (* (+ 31 402) 83)
    . All dies wird sehr einfach sein, sobald wir
    den Ableitungsbaum als Datenstruktur vorliegen haben.
    
    |> Topic
        Eine Datenstruktur für Ableitungsbäume
        
    Für meine Implementierung in Java erschaffe ich für jedes Nichtterminal $X$
    ein Interface
    und für jede Produktionsregel $X \rightarrow \alpha$ eine Klasse,
    die das Interface $X$ implementiert und $\alpha$ als Klassenvariable enthält.
    |> ul
        |> li
            |> tt
                interface Expression
            \ wird implementiert von
            |> ul
                |> li
                    |> tt
                        class Sum
                    , die als Klassenvariable 
                    |> tt
                        Exrepssion e1, e2
                    \ enthält,
                |> li
                    |> tt
                        class Product
                    , die als Klassenvariable 
                    |> tt
                        Exrepssion e1, e2
                    \ enthält,
                |> li
                    |> tt
                        class JustNumber
                    , die als Klassenvariable nur eine 
                    |> tt
                        Number number
                    enthält;
        |> li
            |> tt
                interface Number
            \ wird implementiert von
            |> ul
                |> li
                    |> tt
                        class MultiDigitNumber
                    , die als Klassenvariable eine
                    |> tt
                        Number
                    \ und eine 
                    |> tt
                        Digit
                    \ erhält und
                |> li
                    |> tt
                        class SingleDigitNumber
                    , die als Klassenvariable ein 
                    |> tt
                        Digit
                    enthält;
        |> li
            |> tt
                interface Digit
            \ wird implementiert von
            |> tt
                class DigitOne
            ,
            |> tt
                class DigitTwo
            ,
            |> tt
                class DigitThree
            ,
            |> tt
                class DigitFour
            ,
            |> tt
                class DigitFive
            ,
            |> tt
                class DigitSix
            ,
            |> tt
                class DigitSeven
            ,
            |> tt
                class DigitEight
            \ und
            |> tt
                class DigitNine
            .
            
    In unserem Anwendungsfall hat jedes Interface eine Methode
    |> tt
        public int toInt()
    . Interface 
    |> tt
        Expression
    \ hat zusätzlich noch
    die Methode 
    |> tt
        String toPrefixNotation()
    . Ich schreibe auch ein
    Über-Interface 
    |> tt
        ParseObject
    , das alle Interfaces zusammenfasst.
    Um uns das Debugging zu erleichtern, überschreibe ich in jeder Klasse die Methode
    |> tt
        public String toString()
    .
