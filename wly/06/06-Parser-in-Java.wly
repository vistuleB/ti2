|> Sub
    title=Einen Parser in Java implementieren
    |> div
        class=well alert-info
        Den vollständigen Quelltext, den wir in der Vorlesung
        geschrieben haben, finden Sie in der Datei [ArithmeticGrammar.java](https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/code/parsing/arithmetic-in-class/ArithmeticGrammar.java).

    Ich möchte nun eine kontextfreie Grammatik für arithmetische
    Ausdrücke der Form `((31+402)*83)` entwerfen. Der Einfachheit
    halber bestehe ich auf strenger Klammerung, so wäre
    `(2*(1+2+3))` zum Beispiel nicht erlaubt. Unsere Grammatik
    soll allgemeine Dezimalzahlen darstellen können. Das
    Alphabet ist somit
    $\Sigma = \{\texttt{0},\texttt{1},\texttt{2},\texttt{3},\texttt{4},
    \texttt{5},\texttt{6},\texttt{7},\texttt{8},\texttt{9},
    \texttt{+},\texttt{*},\texttt{(},\texttt{)}\}$.
    Die Produktionsregeln sind:

    \begin{align*}
    E&\rightarrow N \tag{JustNumber} \\
    E&\rightarrow \texttt{(}E \texttt{+} E\texttt{)} \tag{Sum} \\
    E&\rightarrow \texttt{(}E \texttt{*} E\texttt{)} \tag{Product}\\
    N&\rightarrow D \tag{SingleDigit} \\
    N&\rightarrow ND \tag{NumberDigit} \\
    D&\rightarrow \texttt{0}\ | \ \texttt{1}\ | \ \texttt{2}\ | \ \texttt{3}\ | \ \texttt{4}\ | \
    \texttt{5}\ | \ \texttt{6}\ | \ \texttt{7}\ | \ \texttt{8}\ | \ \texttt{9}
    \end{align*}

    Die Nichtterminale sind also $E$ (Expression), $N$
    (Number) und $D$ (Digit). Wir haben auch den einzelnen
    Produktionen Namen gegeben, bis auf die der Form
    $D \rightarrow i$. Was soll nun unser Parser tun?
    Er soll, gegeben ein Eingabewort $w \in L$, den _Ableitungsbaum_
    konstruieren, für `((31+402)*83)` also

    |> figure
        |> img
            style=height:20em
            src=./img/context-free/arithmetic-syntax-tree.svg

    Wie wir diesen Baum in Java repräsentieren, darüber
    sprechen wir in einer Minute. Zuerst aber: wir wollen
    mit diesem Baum etwas Sinnvolles tun. Zum Beispiel
    _auswerten_, so dass am Ende eine Zahl rauskommt, im
    obigen Beispiel also $(31 + 402) \cdot 83 = 35939$.
    Oder den Ausdruck umformen von Infix-Notation zu Präfixnotation,
    also`(* (+ 31 402) 83)`. All dies wird sehr einfach
    sein, sobald wir den Ableitungsbaum als Datenstruktur
    vorliegen haben.

    |> Topic
        Eine Datenstruktur für Ableitungsbäume

    Für meine Implementierung in Java erschaffe ich für
    jedes Nichtterminal $X$ ein Interface und für jede
    Produktionsregel $X \rightarrow \alpha$ eine Klasse,
    die das Interface $X$ implementiert und $\alpha$ als
    Klassenvariable enthält.

    |> ul
        |> li
            `interface Expression` wird implementiert von

            |> ul
                |> li
                    `class Sum`, die als Klassenvariable `Exrepssion e1,
                    e2` enthält,
                |> li
                    `class Product`, die als Klassenvariable `Exrepssion
                    e1, e2` enthält,
                |> li
                    `class JustNumber`, die als Klassenvariable nur eine
                    `Number number`enthält;
        |> li
            `interface Number` wird implementiert von

            |> ul
                |> li
                    `class MultiDigitNumber`, die als Klassenvariable
                    eine`Number` und eine `Digit` erhält und
                |> li
                    `class SingleDigitNumber`, die als Klassenvariable
                    ein `Digit`enthält;
        |> li
            `interface Digit` wird implementiert von`class DigitOne`,`class
            DigitTwo`,`class DigitThree`,`class DigitFour`,`class
            DigitFive`,`class DigitSix`,`class DigitSeven`,`class
            DigitEight` und`class DigitNine`.

    In unserem Anwendungsfall hat jedes Interface eine
    Methode`public int toInt()`. Interface `Expression`
    hat zusätzlich noch die Methode `String toPrefixNotation()`.
    Ich schreibe auch ein Über-Interface `ParseObject`,
    das alle Interfaces zusammenfasst. Um uns das Debugging
    zu erleichtern, überschreibe ich in jeder Klasse die
    Methode`public String toString()`.