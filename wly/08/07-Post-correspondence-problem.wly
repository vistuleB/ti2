|> Sub
    title=Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem

    Die Unentscheidbarkeit des Halteproblems mag auf den
    ersten Blick esoterisch anmuten. Es taucht ja nur auf,
    weil die Problemstellung irgendwie selbstreferenziell
    ist. Das täuscht: Unentscheidbarkeit taucht in vielen
    Bereichen der theoretischen Informatik und der
    Mathematik auf, auch bei Fragestellungen, die auf den
    ersten Blick nichts mit Turingmaschinen zu tun haben
    und völlig harmlos wirken. Wie zum Beispiel das rein
    kombinatorische _Postsche Korrespondenzproblem._ Im
    Postschen Korrespondenzproblem haben wir endlich viele
    Kärtchen (auch _Kacheln_ genannt) gegeben, die oben
    und unten jeweils ein Wort haben. Wir müssen die
    Kärtchen so nebeneinander legen, dass oben und unten
    das gleiche Wort entsteht; jedes Kärtchen kann
    beliebig oft verwendet werden. Im folgenden Beispiel
    wird das beige-farbene Kärtchen zweimal verwendet:

    |> Carousel
        height=18em
        src=img/pcp/example-wikipedia/01.svg
        src=img/pcp/example-wikipedia/02.svg
        src=img/pcp/example-wikipedia/03.svg
        src=img/pcp/example-wikipedia/04.svg
        src=img/pcp/example-wikipedia/05.svg
        src=img/pcp/example-wikipedia/06.svg
        src=img/pcp/example-wikipedia/07.svg
        src=img/pcp/example-wikipedia/08.svg
        src=img/pcp/example-wikipedia/09.svg

    (Diese Beispielinstanz ist von
    [Wikipedia](https://en.wikipedia.org/wiki/Post_correspondence_problem);
    die graphische Darstellung stammt von mir.) Schauen
    wir uns ein weiteres, komplizierteres Beispiel an.
    Hier führen wir eine Sonderregel ein, nämlich dass man
    mit der türkisen Kachel (der ersten) anfangen muss:

    |> Carousel
        height=18em
        src=img/pcp/example-expo/01.svg
        src=img/pcp/example-expo/02.svg
        src=img/pcp/example-expo/03.svg
        src=img/pcp/example-expo/04.svg
        src=img/pcp/example-expo/05.svg
        src=img/pcp/example-expo/06.svg
        src=img/pcp/example-expo/07.svg
        src=img/pcp/example-expo/08.svg
        src=img/pcp/example-expo/09.svg
        src=img/pcp/example-expo/10.svg
        src=img/pcp/example-expo/11.svg
        src=img/pcp/example-expo/12.svg
        src=img/pcp/example-expo/13.svg
        src=img/pcp/example-expo/14.svg
        src=img/pcp/example-expo/15.svg
        src=img/pcp/example-expo/16.svg
        src=img/pcp/example-expo/17.svg
        src=img/pcp/example-expo/18.svg
        src=img/pcp/example-expo/19.svg
        src=img/pcp/example-expo/20.svg
        src=img/pcp/example-expo/21.svg
        src=img/pcp/example-expo/22.svg
        src=img/pcp/example-expo/23.svg
        src=img/pcp/example-expo/24.svg
        src=img/pcp/example-expo/25.svg

    Können Sie das zweie PCP-Puzzle lösen und zu Ende
    führen? Informell sehen wir bereits: um das Puzzle zu
    lösen, müssen wir die $\texttt{x}$ loswerden. Das
    geht nur, indem wir jedes $\texttt{x}$ mit Hilfe des
    fünften (beigefarbenen) Kärtchens nach rechts
    schieben, bis es auf ein $\texttt{a}$ stösst, wo wir
    es mit dem sechsten (violetten) verschwinden lassen
    können. Jedes $\texttt{x}$ verdoppelt also die Anzahl
    der Einsen. Dieses PCP "berechnet" in gewisser Weise
    die Funktion $n \mapsto 2^n$. In ganz ähnlicher Weise
    können wir zu jeder Turingmaschine ein PCP-Puzzle
    bauen, das diese Maschine "simuliert". Aber eins nach
    dem anderen. Wir beginnen mit Terminologie.

    |> Definition
        Sei $\Sigma$ ein endliches Alphabet.

        |> ul
            |> li
                Eine _Kachel_ (auch _Kärtchen_ genannt) ist ein Paar
                $(\alpha : \beta) \in \Sigma^* \times \Sigma^*$. Hier
                bezeichnet $\alpha$ das Wort auf der oberen Hälfte
                der Kachel und $\beta$ das auf der unteren.

            |> li
                Ein PCP-Puzzle (oder einfach nur Puzzle in diesem
                Zusammenhang) ist eine endliche Menge $S$ von
                Kacheln.

            |> li
                Eine Kachelung ist eine Folge $s$ von Kacheln aus $S$,
                also

                \begin{align*}
                s = (\alpha_{1} : \beta_{1}) (\alpha_{2} : \beta_{2}) \dots
                (\alpha_{m} : \beta_{m})
                \end{align*}

                Für eine Kachelung $s$ definieren wir den _oberen
                Teil_ $\top(s)$ und den _unteren Teil_ $\bottom(s)$:

                \begin{align*}
                \top(s)&:= \alpha_1 \alpha_2 \dots \alpha_m \\
                \bottom(s)&:= \beta_1 \beta_2 \dots \beta_m \\
                \end{align*}

            |> li
                Eine Kachelung $s$ ist eine _Lösung_ des Puzzles,
                wenn $\top(s) = \bottom(s)$ gilt.

    Illustrieren wir die Definitionen noch einmal anhand
    des ersten Beispiels:

    |> figure
        |> img
            style=height:12em
            src=img/pcp/example-wikipedia/04.svg

    Das Puzzle besteht aus drei Kacheln:

    \begin{align*}
    k_1 &:= (a : baa) \\
    k_2 &:= (ab : aa) \\
    k_3 &:= (bba : bb) \ .
    \end{align*}

    Oben sehen wir eine Kachelung $s := k_3 k_2 k_3$ und

    \begin{align*}
    \top(s) &= bbaabbba \\
    \bottom(s) &= bbaabb \ .
    \end{align*}

    Die Kachelung $k_3 k_2 k_3$ ist noch keine Lösung,
    aber $k_3 k_2 k_3 k_1$ ist eine. Für ein festes
    $\Sigma$ können wir natürlich ein PCP-Puzzle
    codieren, indem wir die Menge $S$ der Kacheln
    codieren, z.B. über dem Alphabet
    $\Sigma \cup \{(, :, )\}$. Das erste Beispielpuzzle
    $S$ wäre dann

    \begin{align*}
    \enc(S) := (a:baa)(ab:aa)(bba:bb)
    \end{align*}

    Somit können wir das Postsche Korrespondenzproblem
    formal als Sprache definieren:

    \begin{align*}
    {\rm PCP} := \{ \enc(S) \ | \ S \textnormal{ ist ein PCP-Puzzle und hat eine Lösung} \} \ .
    \end{align*}

    |> Theorem
        PCP ist unentscheidbar.

    |> Proof
        Wir zeigen: wenn PCP entscheidbar _wäre_, dann _wäre_
        auch $\halt$ entscheidbar. Da letzteres jedoch
        unentscheidbar ist, muss auch PCP unentscheidbar sein.
        Mehr im Detail: für eine Turingmaschine $M$ und ein
        Eingabewort $x$ konstruieren wir ein Puzzle $S$, so
        dass $S$ genau dann eine Lösung hat, wenn $M(x)$
        akzeptiert. Ein Entscheidungsalgorithmus für das PCP
        könnte somit auch $\halt$ entscheiden. Wie so oft in
        ähnlichen Beweisen machen wir einen Zwischenschritt.
        Das _Modifizierte Postsche Korrespondenzproblem (MPCP)
        _ ist genau das gleiche wie das PCP, nur dass es in
        $S$ eine markierte Startkachel gibt und jede Lösung
        mit dieser Startkachel beginnen muss. Es ist also ein
        "strengeres" Problem als das PCP.

        |> Lemma
            Gegeben ein MPCP-Puzzle $S$, so können wir ein
            (normales) PCP-Puzzle $S'$ erstellen, mit der
            Eigenschaft, dass $S$ eine Lösung hat genau dann,
            wenn $S'$ eine Lösung hat.

        |> Proof
            Im MPCP zwingen uns bereits die Spielregeln, mit der
            markierten Startkachel zu beginnen. Wir müssen nun,
            von $S$ ausgehend, ein ähnliches Puzzle bauen, in
            welchem es zwar keine Startkachel gibt, aber dennoch
            nur eine Kachel überhaupt als Anfang in Frage kommt.
            Das geht mit einem Trick, in dem wir jede Kachel durch
            eine "gesternte Variante" ersetzen:

            |> figure
                |> img
                    style=height:5em
                    src=img/pcp/mpcp-to-pcp-01.svg

            wobei * ein neues Symbol ist. Offensichtlich kann
            keine solche Kachel ganz links stehen, da ja dann
            bereits das erste Symbol nicht übereinstimmen würde.
            Für die markierte Startkachel erstellen wir eine
            weitere "gesternte" Variante:

            |> figure
                |> img
                    style=height:5em
                    src=img/pcp/mpcp-to-pcp-02.svg

            Die gesternten Kacheln zwingen uns nun dazu, mit der
            markierten zu beginnen, da diese ja die einzige ist,
            wo das erste Symbol oben und unten übereinstimmt. Wir
            können nun jede $S'$ -Kachelung in eine $S$-Kachelung
            übersetzen; allerdings steht bei der $S$-Kachelung
            rechts unten ein *, rechts oben aber nicht. Wir
            erstellen nun eine weitere Kachel, die am rechten Rand
            und nur dort eingesetzt werden kann:

            |> figure
                |> img
                    style=height:4em
                    src=img/pcp/mpcp-to-pcp-03.svg

            Sie sehen: die letzte Kachel ist die einzige, die am
            rechten Rand stehen kann. Sollte nun das MPCP-Puzzle
            $S$ eine Lösung haben (die dann laut Spielregeln auch
            mit der markierten Startkachel beginnt), so können wir
            daraus eine Lösung des PCP-Puzzles $S'$ konstruieren,
            indem wir einfach jede $S$ -Kachel durch die
            entsprechende $S'$ -Kachel ersetzen (Vorsicht: sollte
            die markierte Startkachel in der $S$-Lösung mehrfach
            vorkommen, so muss in $S'$ anfangs die "türkise"
            Version der Kachel genommen werden, mit * oben und
            unten; jedes weitere Exemplar muss dann in $S'$ durch
            die violette türkise Kachel ersetzt werden). Ganz zum
            Schluss hängen wir noch die Kachel für den rechten
            Rand an. Sollte umgekehrt das PCP-Puzzle $S'$ eine
            Lösung haben, so erhalten wir eine Lösung des MPCP
            Puzzles $S$, indem wir alle Sterne herausstreichen
            und die rechte Endkachel entfernen.
            |> QED

        Nun wissen wir also, dass wir den "Spieler" zwingen
        können, mit einer bestimmten Kachel zu beginnen, ohne
        dies explizit in die Spielregeln aufnehmen zu müssen.
        Unser Ziel ist nun: gegeben eine Turingmaschine $M$
        und ein Inputwort $x$, darauf aufbauend ein
        MPCP-Puzzle $S$ zu konstruieren, das genau dann eine
        Lösung hat, wenn $M(x) = \texttt{accept}$ gilt.
        Erinneren wir uns: eine _Konfiguration_ einer
        Turingmaschine ist eine Folge

        \begin{align*}
        w_1 w_2 \dots w_{j-1} q w_j \dots w_m
        \end{align*}

        mit $w_i \in \Gamma$ und $q \in Q$. Die Bedeutung
        ist, dass auf dem Band das Wort $w_1 w_2 \dots w_m$
        steht, die Turingmaschine im Zustand $q$ ist und der
        Schreib-Lese-Kopf über den Zeichen $w_j$ steht. Wir
        schreiben also den Zustand unmittelbar _links_ von dem
        Zeichen, über dem er steht. Wenn das Eingabewort
        $x_1 \dots x_n$ und $q_0 \in Q$ der Startzustand,
        dann ist

        \begin{align*}
        C_0 := q_0 x_1 \dots x_n
        \end{align*}

        die Startkonfiguration. Die Berechnung einer
        Turingmaschine ist nun eine Folge von Konfigurationen,
        die wir mit dem $\#$ -Zeichen separieren, also

        \begin{align*}
        \#\# C_0 \# C_1 \# C_2 \# C_3 \# \dots \# C_t
        \end{align*}

        Zwei aufeinanderfolgende Konfigurationen
        $C_i, C_{i+1}$ unterscheiden sich nur in der
        unmittelbaren Umgebung des Schreib-Lese-Kopfes. Der
        Rest ist in beiden Konfigurationen identisch. Die Idee
        ist nun, zuerst eine Startkachel

        |> figure
            |> img
                style=height:3em
                src=img/pcp/halt-to-pcp-01.svg

        zu bauen. Wir sehen: oben "steht etwas über", und
        zwar genau die Startkonfiguration. Wir wollen nun
        weitere Kacheln entwerfen, die es dem Spieler
        erlauben, unten auch die Konfiguration zu legen, ihn
        dabei allerdings zwingen, oben die Folgekonfiguration
        zu legen. Hierfür brauchen wir "Kopierkacheln", die es
        uns erlauben, Zeichen in die Folgekonfiguration zu
        kopieren und "Kopf-Kacheln", die die Aktion am
        Schreib-Lese-Kopf simulieren.

        \begin{align*}
        \delta(q_0, x_1) = (q_1, y, \texttt{R})
        \end{align*}

        ist, dann würden wir folgende Kachel erzeugen und wie
        folgt einsetzen:

        |> Carousel
            height=12em
            src=img/pcp/step-right/01.svg
            src=img/pcp/step-right/02.svg
            src=img/pcp/step-right/03.svg
            src=img/pcp/step-right/04.svg
            src=img/pcp/step-right/05.svg
            src=img/pcp/step-right/06.svg
            src=img/pcp/step-right/07.svg
            src=img/pcp/step-right/08.svg

        Was geschieht nun? Für das Symbol $q_1$, das ja einen
        Zustand bezeichnet, gibt es keine Kopierkachel. Wenn
        nun beispielsweise

        \begin{align*}
        \delta(q_1, x_2) = (q_3, z, \texttt{L})
        \end{align*}

        gilt, dann müssten wir den Kopf wieder nach links
        verschieben, und er würde wiederum ganz am Anfang der
        Konfiguration stehen. Es war also ein Fehler, $y$ per
        Kopierkachel zu kopieren. Wir machen es rückgängig und
        legen eine der Regel
        $\delta(q_1, x_2) = (q_3, z, \texttt{L})$
        entsprechende Kopfkachel:

        |> Carousel
            height=12em
            src=img/pcp/step-left/01.svg
            src=img/pcp/step-left/02.svg
            src=img/pcp/step-left/03.svg
            src=img/pcp/step-left/04.svg
            src=img/pcp/step-left/05.svg

        Hier brauchen wir halt eine Kopfkachel
        $(q_2yz:yq_1x_2)$ für _jedes_ Bandsymbol $y$, da die
        Regel immer anzuwenden ist, egal, welches Symbol $y$
        links vom Schreib-Lese-Kopf steht. Fassen wir
        zusammen, was wir bis jetzt gesehen haben. Wir
        konstruieren Kopierkacheln $(x:x)$, die es dem
        Spieler erlauben, die Konfiguration zu kopieren;
        Kopfkacheln, die den Spieler zwingen, in der Umgebung
        des Schreib-Lese-Kopfes den Regeln der Turingmaschine
        zu folgen; und eine Startkachel, die die
        Startkonfiguration abbildet. Also:

        |> figure
            |> img
                style=height:20em
                src=img/pcp/almost-all-tiles.svg

        Wir sind noch nicht ganz fertig. Wir brauchen noch
        Regeln für den Fall, dass der Schreib-Lese-Kopf am
        Rand des Bandinhaltes steht, konkret also die
        "Umgebung" des Kopfes ein $\texttt{#}$ -Zeichen
        beinhaltet. Wir können entweder weitere Kopf-Kacheln
        entwerfen, die diese Fälle behandeln, oder aber
        "Bandwrweiterungskacheln", die uns erlauben, der
        Konfiguration $C$ links oder rechts ein Leersymbol
        $\_$ anzuhängen. Ich überlasse es an dieser Stelle
        dem Leser / der Leserin, die Details hierfür
        auszuarbeiten. Ganz zum Schluss müssen wir noch
        beschreiben, was geschieht, wenn die Maschine in den
        akzeptierenden Zustand $q^*$ wechselt. Wir erschaffen
        Kacheln, die erlauben, alle Bandsymbole zu löschen,
        bis das Band leer ist:

        |> figure
            |> img
                style=height:6em
                src=img/pcp/tile-delete-symbols.svg

        und ganz am Schluss eine Kachel $(\# : q^* \# \#)$ ,
        um alles abzuschließen. Die letzten zwei Schritte
        sehen dann so aus:

        |> Carousel
            height=10em
            src=img/pcp/finish-00.svg
            src=img/pcp/finish-01.svg
            src=img/pcp/finish-03.svg

        Strenggenommen müssten wir jetzt beweisen, dass das
        MPCP-Puzzle genau dann lösbar ist, wenn die
        Turingmaschine akzeptiert. Hierfür könnten wir zum
        Beispiel zeigen, dass, wenn $s$ eine Kachelung ist,
        in welcher $\top(s)$ und $\bottom(s)$ beide auf dem
        Zeichen $\#$ enden und wenn $\bottom(s)$ nicht das
        Zeichen $q^*$ enthält, dann ist

        \begin{align*}
        \top(s)&= \#\# C_0 \# C_1 \# \dots \# C_{j+1}\# \\
        \bottom(s)&= \#\# C_0 \# C_1 \# \dots \# C_j\# \\
        \end{align*}

        wobei $C_0 = q_0 x_1 \dots x_n$ die
        Startkonfiguration der Turingmaschine ist und jedes
        $C_{i+1}$ die Folgekonfiguration von $C_i$; dass also
        die Teillösung $s$ des Puzzles getreu die Berechnung
        der Turingmaschine abbildet. Wir ersparen uns weitere
        Details.
        |> QED