|> Sub
    title=Reduktionen

    `3-Colorability`{sc} und `CNF-Satisfiability`{sc} sind in NP:
    gegeben ein Graph $G$ und eine Färbung $c$ , so können wir
    effizient feststellen, ob $c$ eine gültige 3-Färbung von $G$
    darstellt; gegeben eine CNF-Formel $F$ und eine Belegung $\alpha$,
    so können wir effizient überprüfen, ob $F$ unter $\alpha$ zu
    `True` auswertet. Können wir `3-Colorability`{sc}
    und`CNF-Satisfiability`{sc} auch effizient entscheiden? Sind sie in
    P? Das ist (Stand: 2025) nicht bekannt. Was wir aber sagen können:
    entweder sind beide effizient lösbar oder beide nicht. Sie sind
    gewissermaßen gleich schwer.

    |> Theorem
        handle=theorem-3-col-to-sat
        Falls `CNF-Satisfiability`{sc} in P ist, dann auch
        `3-Colorability`{sc}.

    |> Proof
        Wir nehmen an, wir hätten einen effizienten Algorithmus
        `is_satisfiable( $F$)`. Wir verwenden diesen, um einen
        Algorithmus `is_3_colorable` zu entwerfen. Sei nun $G = (V,E)$
        ein Graph und $v_1, \dots, v_n$ seine Knoten. Wir führen $3n$
        Boolesche Variable ein:
        $r_1, \dots, r_n, g_1, \dots, g_n, b_1, \dots, b_n$. Die
        Intention hierbei ist, dass $r_i$ anzeigt, ob $v_i$ rot ist und
        so weiter. Wir müssen jetzt Klauseln erschaffen, die die Aussage
        "das ist eine gültige 3-Färbung" als CNF-Formel codieren. Wir
        erschaffen folgende Klauseln:

        \begin{align*}
        &(r_i \vee g_i \vee b_i) \tag{$v_i$ hat mindestens eine Farbe}\\
        &(\bar{r}_i \vee \bar{g}_i) \wedge (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \tag{$v_i$ hat nicht zwei Farben gleichzeitig}
        \end{align*}

        Dies tun wir für jedes $i$. Wir sehen nun: jede Belegung, die
        die obigen Klauseln erfüllt, entspricht einer $3$ -Färbung
        $c: V \rightarrow \{1,2,3\}$, und umgekehrt. Nun müssen wir die
        Aussage _Kante $\{v_i,v_j\}$ ist gültig gefärbt_ formulieren:

        \begin{align*}
        &(\bar{r}_i \vee \bar{r}_j) \tag{$v_i$ und $v_j$ sind nicht beide rot}\\
        &(\bar{g}_i \vee \bar{g}_j) \tag{$v_i$ und $v_j$ sind nicht beide grün}\\
        &(\bar{b}_i \vee \bar{b}_j) \tag{$v_i$ und $v_j$ sind nicht beide blau}\\
        \end{align*}

        und dann alles zusammenwerfen:

        \begin{align*}
        F:=&\quad \bigwedge_{i=1}^n \left( (r_i \vee g_i \vee b_i) \wedge(\bar{r}_i \vee \bar{g}_i)
        \wedge
        (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \right) \wedge \\
        &\bigwedge_{\{v_i, v_j\} \in E} \left(
        (\bar{r}_i \vee \bar{r}_j) \wedge
        (\bar{g}_i \vee \bar{g}_j) \wedge
        (\bar{b}_i \vee \bar{b}_j)
        \right)
        \end{align*}

        Es gilt nun: $G$ ist genau dann $3$-färbbar, wenn $F$ erfüllbar
        ist. Und hier ist nun unser Code für `is_3_colorable:`

        ```orange-comments-listing
        def is_3_colorable(graph):
            F = convert_to_CNF_formula(graph)
            //# F ist die oben beschriebene Formel mit 3n Variablen
            return is_satisfiable(F)
        ```

        Falls Ihnen eine Funktion `find_satisying_assignment` zur
        Verfügung steht, so können Sie natürlich die erfüllende Belegung
        direkt in eine gültige 3-Färbung übersetzen. 
        |> QED

    Das ging recht schnell und direkt, weil die Aussagenlogik
    allgemein genug ist, um Aussagen über endliche Objekte (hier:
    Graphen) effizient zu codieren. Geht es auch andersrum? Wenn uns
    eine Funktion `is_3_colorable` zur Verfügung steht, können wir dann
    auch eine Funktion `is_satisfiable` schreiben? Wir machen einen
    Zwischenschritt und schreiben mithilfe von `is_3_colorable` einen
    effizienten Algorithmus für $3$-SAT; dies ist
    `CNF-Satisfiability`{sc} mit der Einschränkung, dass $F$ eine $3$
    -CNF-Formel ist, dass also jede Klausel nur drei Literale enthält.
    Beachten Sie, dass die Formel $F$, die wir im Beweis von Theorem
    >>theorem-3-col-to-sat erstellt haben, eine solche 3-CNF ist.

    |> Theorem
        handle=theorem-3-sat-to-3-col
        Falls `3-Colorability`{sc} in P ist, dann auch`3-SAT`{sc}.

    |> Proof
        Wir gehen konzeptuell ähnlich vor wie oben. Uns ist eine
        3-CNF-Formel $F$ gegeben. Wir müssen jetzt einen Graphen
        $G = (V,E)$ bauen, der die Aussage _$F$ ist erfüllbar_ irgendwie
        in seiner 3-Färbbarkeit oder eben Nicht-3-Färbbarkeit codiert.
        Dies ist schwieriger. Als ersten Schritt legen wir fest, dass die
        drei Farben nicht $1$, $2$,

        $3$ sein sollen, sondern `True`, `False`, `Neutral`.

        |> Carousel
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-01.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-02.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-03.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-04.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-05.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-06.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-07.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-08.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-09.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-10.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-11.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-12.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-13.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-14.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-15.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-16.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-17.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-18.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-19.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-20.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-21.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-22.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-23.svg
            src=img/09-complexity-theory/sat-to-col/sat-to-col-01-24.svg

        Wir wiederholen die beschriebene Konstruktion für jede Klausel
        in $F$. Wir erhalten einen Graphen $G$, der genau dann
        $3$-färbbar ist, wenn $F$ erfüllbar ist. Auch können wir direkt
        eine gültige $3$-Färbung in eine erfüllende Belegung übersetzen
        und umgekehrt. Hier ist also der Code:

        ```orange-comments-listing
        def is_3CNF_satisfiable(the_3_cnf_formula):
            G = cOnvert_to_graph(the_3_cnf_formula)
            //# G ist der oben konstruierte Graph
            return is_3_colorable(G)
        ```

        |> QED

    Wir haben also gezeigt, wie man eine $3$-CNF $F$ in einen Graphen
    $G$ umwandelt, so dass

    \begin{align*}
    F \textnormal{ ist erfüllbar } \Longleftrightarrow G \textnormal{ ist $3$-färbbar}
    \end{align*}

    gilt. Allerdings ging das nur unter der Annahme, dass $F$ eine $3$
    -CNF ist. Wie verhält es sich, wenn $F$ eine allgemeine CNF-Formel
    ist?

    |> Theorem
        handle=theorem-sat-to-3-sat
        Es gibt einen effizienten Algorithmus, der als Input eine
        CNF-Formel $F$ nimmt und eine 3-CNF-Formel $F'$ ausgibt, so dass
        gilt:

        \begin{align*}
        F \textnormal{ ist erfüllbar } \Longleftrightarrow F' \textnormal{ ist erfüllbar } \ .
        \end{align*}

        Falls es einen effizienten Algorithmus für $3$ -SAT gibt, dann
        also auch einen für CNF-SAT.

    |> Proof
        Wir starten mit $F_0 := F$ und definieren eine Folge
        $F_0, F_1, \dots$ von CNF-Formeln. Sei $F_i$ die derzeit letzte
        erzeugte CNF-Formel. Falls $F_i$ eine Klausel $C$ mit vier oder
        mehr Literalen enthält, führen wir eine Operation durch, die $C$
        durch zwei neue, kleinere Klauseln ersetzt: sei

        \begin{align*}
        C = (u_1 \vee u_2 \vee u_3 \vee u_4 \vee \dots \vee u_k)
        \end{align*}

        mit $k \geq 4$. Wir führen eine neue, bisher nicht verwendete
        Variable $z$ ein und erschaffen die Klauseln

        \begin{align*}
        C_1 := (\bar{z} \vee u_1 \vee u_2) \\
        C_2 := (z \vee u_3 \vee \dots \vee u_k)
        \end{align*}

        Wir entfernen nun $C$ und fügen $C_1$ und $C_2$ ein und erhalten
        eine neue CNF-Formel $F_{i+1}$. Wir sehen nun: wenn $\alpha$ die
        Formel $F_{i+1}$ erfüllt, dann erfüllt sie auch $F_i$; umgekehrt
        wenn die Belegung $\beta$ die Formel $F_i$ erfüllt, dann erfüllt
        $\beta$ insbesondere $C$; wir bauen nun eine neue Belegung, die
        auch $z$ einen Wert zuweist und dann $C_1$ und $C_2$ erfüllt:
        falls (1) $\beta$ die Klausel $(u_1 \vee u_2)$ erfüllt, dann
        setzen wir $z$ auf $1$, also
        $\alpha := \beta \cup [z \mapsto 1]$. Die Belegung $\alpha$
        erfüllt nun $C_1$, weil $\beta$ das bereits tut, und $C_2$, weil
        $\alpha(z)=1$ ist; falls jedoch (2) $\beta$ die Klausel
        $(u_1 \vee u_2)$ nicht erfüllt, dann muss sie, da sie ja $C$
        erfüllt, die Klausel $(u_3 \vee \dots \vee u_k)$ erfüllen und
        erfüllt somit $C_2$, auch ohne Verwendung von $z$. Wir setzen
        nun $z$ auf $0$, also $\alpha := \beta \cup [z \mapsto 0]$ und
        erfüllen sowohl $C_1$ als auch $C_2$. Alle anderen Klauseln sind
        sowieso erfüllt, weil $\beta$ sie bereits erfüllt. Wir sehen:

        \begin{align*}
        F_i \textnormal{ ist erfüllbar } \Longleftrightarrow F_{i+1} \textnormal{ ist erfüllbar } \ .
        \end{align*}

        Die beiden neuen Klauseln $C_1$ und $C_2$ sind jeweils echt
        kleiner als $C$. Der Prozess endet irgendwann mit einer Formel
        $F_t$, in der jede Klausel höchstens drei Literale hat. Dies ist
        unser $F'$.
        |> QED

    Wir haben nun also eine Kette von Implikationen erschaffen:

    |> ul
        |> li
            Wenn `CNF-Satisfiability`{sc} in P, dann auch
            `3-Colorability`{sc}(Theorem >>theorem-3-col-to-sat).

        |> li
            Wenn `3-Colorability`{sc} in P, dann auch `3-SAT`{sc}(Theorem
            >>theorem-3-sat-to-3-col).

        |> li
            Wenn `3-SAT`{sc} in P, dann
            auch`CNF-Satisfiability`{sc}(Theorem >>theorem-sat-to-3-sat).

    Beachten Sie, dass alle Beweise eine ähnliche Form haben: um die
    Aussage _wenn $L_1 \in P$, dann auch $L_2 \in P$_ zu zeigen,
    nehmen wir eine beliebiges $x \in \Sigma_1$ (eine $L_1$-Instanz)
    und wandeln es um in ein $y \in \Sigma_2$ (eine $L_2$-Instanz), so
    dass

    \begin{align*}
    x \in L_1 \Longleftrightarrow y \in L_2
    \end{align*}

    garantiert ist. Wenn es also einen effizienten Algorithmus
    `is_in_L2` gibt, dann können wir mit folgendem Code auch $L_1$
    effizient entscheiden:

    ```listing
    def is_in_L1(x):
        y = convert_from_L1_instance_to_L2_instance(x)
        return is_in_L2(y)
    ```

    Dies ist eine _Reduktion_, wie wir sie schon in Definition
    >>definition-reduction kennengelernt haben, nun aber mit einer
    Aussage über die Laufzeit.

    |> Definition
        handle=definition-polynomial-reduction
        *(Polynomialzeitreduktion)*. Seien $L_1 \subseteq \Sigma_1^*$
        und $L_2 \subseteq \Sigma_2^*$ zwei Sprachen. Eine Funktion
        $f: \Sigma_1^* \rightarrow \Sigma_2^*$ heißt
        _Polynomialzeitreduktion von $L_1$ auf $L_2$ _ wenn

        \begin{align*}
        \forall x \in \Sigma_1^*: \quad x \in L_1
        \Longleftrightarrow f(x) \in L_2
        \end{align*}

        und $f$ in Zeit $\poly(n)$ berechnet werden kann. Wenn es also
        ein Polynom $p: \N \rightarrow \N$ und eine Turingmaschine $M$
        mit Eingabealphabet $\Sigma_1$ und Ausgabealphabet $\Sigma_2$
        gibt, die Laufzeit $p$ hat und $f$ berechnet. Wir schreiben dann
        $L_1 \leq_p L_2$.

    Wenn wir eine Reduktion von $L_1$ auf $L_2$ haben und einen
    effizienten Algorithmus für $L_2$, dann können wir wie in
    `is_in_L1(x)` oben skizziert $L_1$ effizient entscheiden. Formal:

    |> Observation
        Wenn $L_1 \leq_p L_2$ ist und $L_2 \in {\rm P}$, dann auch
        $L_1 \in {\rm P}$.

    Wir haben die folgenden Polynomialzeitreduktionen bereits
    kennengelernt:

    |> ol
        |> li
            `3-Colorability $\leq_p$ CNF-Satisfiability`{sc}

        |> li
            `CNF-Satisfiability $\leq_p$ 3-SAT`{sc}

        |> li
            `3-SAT $\leq_p$ 3-Colorability`{sc}

    Erinnern Sie sich an `Independent Set`{sc}: gegeben ein Graph $G$
    und eine Zahl $k$, gibt es eine unabhängige Menge $X \subseteq V$
    mit $|X| \geq k$?

    |> Theorem
        `3-SAT $\leq_p$ Independent Set`{sc}.

    |> Proof
        Gegeben sei eine 3-CNF-Formel $F$ mit $n$ Variablen und $m$
        Klauseln. Wir bauen folgenden Graphen $G$:

        |> figure
            |> img
                style=height:20em
                src=img/09-complexity-theory/sat-to-independent-set/3sat-to-IS.svg

        und setzen $k:=n+m$. Wir müssen nun folgendes zeigen:

        \begin{align*}
        F \textnormal{ ist erfüllbar} \Longleftrightarrow
        G \textnormal{ hat eine unabhängige Menge der Größe $k$}
        \end{align*}

        Falls $\alpha$ eine erfüllende Belegung von $F$ ist, dann gibt
        es folgende unabhängige Menge der Größe $k$:

        |> ul
            |> li
                Für jede Variable $x$ nehmen wir $x$ in $I$ auf, falls
                $\alpha(x)=1$ ist, ansonsten $\bar{x}$.

            |> li
                Für jede Klausel $C = (u \vee v \vee w)$ gibt es ein
                erfülltes Literal, sagen wir $u$. Dieser entspricht dem
                Klauselknoten $u_C$, der mit mit dem Literalknoten $\bar{u}$
                verbunden. Da $\alpha(u) = 1$ und $\alpha(\bar{u}) = 0$ ist,
                ist $u \not \in I$ und wir können $u_C$ in $I$ aufnehmen.

            |> li
                Unsere Menge $I$ enthält $n$ Literalknoten und $m$
                Klauselknoten, also insgesamt $k$ Knoten.

        Für die Gegenrichtung nehmen wir an, dass $I$ eine unabhängige
        Menge von $G$ ist und $|I| = n+m$ gilt. Da $I$ pro Literalpaar
        und pro Klauseldreieck höchstens einen Knoten enthalten kann,
        enthält $I$ _genau_ einen pro Literalpaar und Klauseldreieck.
        Wir definieren nun eine Belegung $\alpha$ wie folgt: wenn für
        eine Variable $x$ der Literalknoten $x$ in $I$ ist, setzen wir
        $\alpha(x)=1$; falls $\bar{x}$ in $I$ ist, setzen wir
        $\alpha(x)=0$. Wir behaupten nun, dass $\alpha$ die Formel $F$
        erfüllt. Sei $C= (u \vee v \vee w)$ eine beliebige Klausel von
        $F$. Nach obiger Überlegung enthält $I$ genau einen
        Klauselknoten von $C$, sagen wir $u_C$ . Das heißt somit, dass
        der Literalknoten $\bar{u}$ nicht in $I$ ist - sonst wäre $I$ ja
        nicht unabhängig. Somit muss $u \in I$ gelten und
        $\alpha(u) = 1$, und $\alpha$ erfüllt $C$ .
        |> QED

    |> Exercise
        Zeigen Sie `Independent Set $\leq_p$ SAT`{sc}. Also: Gegeben
        einen Graphen $G$ und eine Zahl $k \in \N$, zeigen Sie, wie man
        die Aussage _$G$ hat eine unabhängige Menge der Größe $k$_ als
        aussagenlogische Formel in CNF darstellen kann.

        *Hinweis:* Die Aussage _"$I$ ist eine unabhängige Menge von $G$_
        ist leicht darzustellen als CNF-Formeln. Die Aussage _" $I$ hat
        Größe $k$"_ ist schwieriger. Sie müssen quasi _zählen_.

    |> SubtopicAnnouncement
        `Hamilton Path`{sc}und `Hamilton Cycle`{sc}

    Sei $G = (V,E)$ ein Graph. Ein _Hamiltonscher Kreis_ ist ein
    Kreis, der durch alle Knoten geht. Es muss ein _Kreis_ sein;
    Kantenzüge, die einen Knoten mehrmals durchlaufen, sind also nicht
    erlaubt. Hier sehen Sie einen Graphen mit Hamiltonschem Kreis:

    |> Carousel
        height=20em
        src=img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-01.svg
        src=img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-02.svg

    Ein _Hamiltonscher Pfad_ ist ein Pfad mit $|V|$ Knoten. Auch hier
    gilt: kein Knoten darf mehrfach besucht werden. Der untere Graph,
    der _Petersen-Graph_, hat keinen Hamiltonschen Kreis, dafür aber
    einen Hamiltonschen Pfad:

    |> figure
        |> img
            style=height:20em
            src=img/09-complexity-theory/hamilton-path-and-cycle/hamilton-02-01.svg

    Wir definieren nun die zwei entsprechenden Entscheidungsprobleme:

    |> Problem
        `(Hamilton Cycle).`{sc} Gegeben ein Graph $G=(V,E)$, gibt es in
        $G$ einen Kreis der Länge $|V|$, der also durch alle Knoten
        geht?

    |> Problem
        `(Hamilton Path).`{sc} Gegeben ein Graph $G=(V,E)$ , gibt es in
        $G$ einen Pfad der Länge $|V|-1$, der also alle $|V|$ Knoten
        enthält?

    |> Theorem
        handle=theorem-ham-cycle-to-path
        `Hamilton Cycle $\leq_p$ Hamilton Path`{sc}

    |> Highlight
        *(Falscher) Beweis.* Tasten wir uns langsam heran. Wir stellen
        uns vor, eine Bibliotheksfunktion `has_hamilton_path(G)` zu haben
        und wollen mithilfe dieser eine neue Funktion
        `has_hamilton_cycle(G)` schreiben. Sei $u$ ein beliebiger
        Knoten. Wir wissen: wenn $G$ einen Hamiltonschen Kreis hat, dann
        besucht dieser auch $u$ und im Anschluss einen Nachbarnknoten
        $v$, also mit $\{u,v\} \in E$. Der Graph $G' := G - \{u,v\}$, in
        welchem wir diese Kante löschen, besitzt somit einen
        Hamiltonschen Pfad. Allerdings kann es sein, dass $G'$ sowieso
        einen Hamiltonschen Pfad besitzt, der allerdings nicht $u$ und
        $v$ als Endknoten hat, so dass er sich mit $\{u,v\}$ nicht zu
        einem Hamiltonschen Kreis schließt. Wir müssen irgendwie die
        Frage beantworten können: besitzt $G'$ einen Hamiltonschen Pfad,
        der $u$ und $v$ als Start- bzw. Endknoten hat? Dies ist einfach:
        wir können neue Knoten $s$ und $t$ und die Kanten $\{s,u\}$ und
        $\{t,v\}$ einführen. Da $s$ und $t$ nun Grad $1$ haben, muss ein
        Hamiltonscher Pfad, wenn er denn existiert, $u$ und $v$ als
        Endknoten haben. Sei also $G'' := G' + \{s,u\} + \{t,v\}$.

        |> div
            class=well container-fluid subtheorem
            *Beobachtung:* $G$ hat genau dann einen Hamiltonschen Kreis
            durch die Kante $\{u,v\}$ , wenn $G''$ einen Hamiltonschen
            Pfad hat.

        |> Carousel
            height=20em
            src=img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-01.svg
            src=img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-02.svg

        Woher wollen wir allerdings wissen, ob der Kreis in $G$ (wenn es
        ihn denn gibt) überhaupt durch $\{u,v\}$ geht? Vielleicht gibt
        es ja einen, aber keinen durch $\{u,v\}$, so dass dann
        `has_hamilton_path( $G''$)` mit `False` antwortet, obwohl wir
        gerne ein `True` hätten. Um das zu verhindern, können wir ja
        _alle_ Nachbarn von $u$ durchprobieren. Wenn einer klappt, dann
        haben wir unseren Kreis; wenn es überhaupt einen Kreis gibt, dann
        klappt es auch mit einem Nachbarn (in der Tat: sogar mit zweien).

        ```listing
        def has_hamilton_cycle(G):
            u = ein beliebiger Knoten
            for v in neighbors[u]:
            H = G - {u,v} + {s,u} + {t,v}
            if has_hamilton_path(H):
            return True
            return False
        ```

        Falls nun `has_hamilton_path` polynomielle Laufzeit $O(n^k)$
        hat, so hat `has_hamilton_cycle` eine Laufzeit von $O(n^{k+1})$,
        auch polynomiell.
        |> QED

    Was ist nun an diesem Beweis falsch? Nun, der Begriff der
    Reduktion, dem wir uns ja mit der Notation $\leq_p$ verpflichten,
    verlangt, dass wir auf Eingabe $G$ _einen_ Graphen $G'$ bauen, mit
    der Eigenschaft, dass $G$ genau dann einen Hamiltonschen Kreis
    hat, wenn $G'$ einen Hamiltonschen Pfad hat. Uns steht also genau
    _ein_ Aufruf von `has_hamilton_path` zu. Aber ganz wertlos ist der
    obige Beweis dennoch nicht, zeigt er doch, dass, falls `Hamilton
    Path $\in$ P`{sc} ist, dann auch `Hamilton Cycle $\in$ P`{sc}. Der
    Fachbegriff für das, was unsere obige Funktion `has_hamilton_cycle`
    tut, nennt sich _Cook-Reduktion_, nach Stephen Cook, einem der
    Väter der Klasse NP. Eine Reduktion, die dem strengen
    Reduktionsbegriff folgt, also Definition
    >>definition-polynomial-reduction, nennt man in Abgrenzung dazu
    _Karp-Reduktion_ nach Richard Karp, ein weiterer NP-Vater.

    |> Exercise
        Geben Sie einen "richtigen" Beweis für Theorem
        >>theorem-ham-cycle-to-path, also eine Karp-Reduktion.

    |> Exercise
        Zeigen Sie `Hamilton Path $\leq_p$ Hamilton Cycle`{sc}. Wenn es
        Ihnen einfacher scheint, geben Sie erst einmal eine
        Cook-Reduktion.